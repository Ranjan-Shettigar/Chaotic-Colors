<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaotic Abstract Pattern Generator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            gap: 10px;
        }
        button {
            background: #fff;
            color: #111;
            border: none;
            padding: 12px 24px;
            border-radius: 30px;
            font-family: inherit;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease;
        }
        button:hover {
            transform: scale(1.05);
        }
        button:active {
            transform: scale(0.98);
            background: #eee;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="abstractCanvas"></canvas>

    <div class="controls">
        <button id="regenerateButton">Generate New</button>
        <button id="downloadButton">Download 4K</button>
        <button id="toggleResolutionButton">Toggle 4K View</button>
    </div>

    <script>
        const canvas = document.getElementById('abstractCanvas');
        const ctx = canvas.getContext('2d');
        const regenerateButton = document.getElementById('regenerateButton');
        const downloadButton = document.getElementById('downloadButton');
        const toggleResolutionButton = document.getElementById('toggleResolutionButton');

        let colorPalette = []; // Will hold the current art's palette
        let currentArtConfig = null; // Will store the current art configuration
        let is4KMode = false; // Track whether 4K rendering is enabled

        /**
         * Generates a random number within a given range.
         * @param {number} min - The minimum value.
         * @param {number} max - The maximum value.
         * @returns {number} A random number between min and max.
         */
        function randomInRange(min, max) {
            return Math.random() * (max - min) + min;
        }

        /**
         * Picks a random color from the generated palette with slight variations.
         * @returns {string} An HSL color string.
         */
        function getRandomColor() {
            // Pick a random base hue from the current palette
            const baseColor = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            
            // Add slight variations to lightness and saturation for more dynamism
            const saturation = randomInRange(90, 100);
            const lightness = randomInRange(50, 70);
            return `hsl(${baseColor.h}, ${saturation}%, ${lightness}%)`;
        }

        /**
         * Generates a harmonious color palette based on a random color scheme.
         */
        function generateColorPalette() {
            const baseHue = randomInRange(0, 360);
            const schemeType = Math.random();
            
            colorPalette = [{ h: baseHue }]; // Start with the base color

            if (schemeType < 0.33) { // Analogous: colors next to each other
                colorPalette.push({ h: (baseHue + 30) % 360 });
                colorPalette.push({ h: (baseHue + 60) % 360 });
                colorPalette.push({ h: (baseHue - 30 + 360) % 360 });
            } else if (schemeType < 0.66) { // Triadic: 3 evenly spaced colors
                colorPalette.push({ h: (baseHue + 120) % 360 });
                colorPalette.push({ h: (baseHue + 240) % 360 });
            } else { // Split-Complementary: a base color and two adjacent to its complement
                const complement = (baseHue + 180) % 360;
                colorPalette.push({ h: (complement - 30 + 360) % 360 });
                colorPalette.push({ h: (complement + 30) % 360 });
            }
        }

        /**
         * Generates the abstract art on the canvas.
         */
        function generateArt() {
            // 0. Generate a new harmonious color palette for this artwork.
            generateColorPalette();

            // 1. Set canvas size.
            const aspectRatio = 16 / 9;
            let width, height;
            
            if (is4KMode) {
                // 4K resolution (3840x2160)
                width = 3840;
                height = 2160;
                
                // Scale down if necessary to fit viewport
                const maxWidth = window.innerWidth * 0.95;
                const maxHeight = window.innerHeight * 0.95;
                const scale = Math.min(maxWidth / width, maxHeight / height);
                
                // Apply scaling for display (actual canvas resolution remains 4K)
                canvas.style.width = `${width * scale}px`;
                canvas.style.height = `${height * scale}px`;
            } else {
                // Regular resolution
                width = window.innerWidth * 0.9;
                height = width / aspectRatio;

                if (height > window.innerHeight * 0.9) {
                    height = window.innerHeight * 0.9;
                    width = height * aspectRatio;
                }
                
                // Reset any custom styling
                canvas.style.width = '';
                canvas.style.height = '';
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // --- Configuration ---
            // Increased shape count for more complex patterns.
            const shapeCount = randomInRange(50, 80); 
            // Wider blur range for more varied smoothness.
            const blurRadius = Math.max(width, height) / randomInRange(5, 12); 

            // Define possible blend modes for chaotic interactions
            const blendModes = ['source-over', 'lighten', 'overlay', 'color-dodge', 'hard-light', 'difference'];
            
            // Store all shape data to recreate the exact same image in 4K
            let shapeData = [];

            // 2. Apply filters.
            ctx.filter = `blur(${blurRadius}px) saturate(170%) contrast(110%)`;
            
            // 3. Draw a variety of random, multi-colored shapes
            for (let i = 0; i < shapeCount; i++) {
                // Store the data for this shape
                const shapeInfo = {
                    blendMode: blendModes[Math.floor(Math.random() * blendModes.length)],
                    x1: Math.random() * width,
                    y1: Math.random() * height,
                    r1: 0,
                    colorStops: Math.floor(randomInRange(4, 8)),
                    lineWidth: randomInRange(5, 30),
                    shapeType: Math.random()
                };
                
                // Calculate additional properties
                shapeInfo.x2 = shapeInfo.x1 + randomInRange(-width * 0.1, width * 0.1);
                shapeInfo.y2 = shapeInfo.y1 + randomInRange(-height * 0.1, height * 0.1);
                shapeInfo.r2 = randomInRange(0.1, 0.5) * Math.min(width, height);
                
                // Generate and store colors for gradient stops
                shapeInfo.colors = [];
                for(let j = 0; j < shapeInfo.colorStops; j++) {
                    shapeInfo.colors.push(getRandomColor());
                }
                
                // Store shape-specific properties
                if (shapeInfo.shapeType < 0.4) { // Circle
                    // No additional properties needed
                } else if (shapeInfo.shapeType < 0.7) { // Rectangle
                    shapeInfo.rectWidth = randomInRange(0.2, 1.0) * width;
                    shapeInfo.rectHeight = randomInRange(0.2, 1.0) * height;
                    shapeInfo.rotation = randomInRange(0, Math.PI * 2);
                } else if (shapeInfo.shapeType < 0.9) { // Bezier Curve
                    shapeInfo.startX = randomInRange(0, width);
                    shapeInfo.startY = randomInRange(0, height);
                    shapeInfo.cp1x = randomInRange(0, width);
                    shapeInfo.cp1y = randomInRange(0, height);
                    shapeInfo.cp2x = randomInRange(0, width);
                    shapeInfo.cp2y = randomInRange(0, height);
                    shapeInfo.endX = randomInRange(0, width);
                    shapeInfo.endY = randomInRange(0, height);
                } else { // Polygon
                    shapeInfo.sides = Math.floor(randomInRange(3, 8));
                    shapeInfo.polyRadius = shapeInfo.r2 * randomInRange(0.8, 1.5);
                    shapeInfo.polyRotation = randomInRange(0, Math.PI * 2);
                }
                
                // Add this shape to our collection
                shapeData.push(shapeInfo);
                
                // Set a random blend mode for this shape for unpredictable color mixing
                ctx.globalCompositeOperation = shapeInfo.blendMode;

                // Create a multi-color radial gradient for each shape
                const gradient = ctx.createRadialGradient(
                    shapeInfo.x1, shapeInfo.y1, shapeInfo.r1, 
                    shapeInfo.x2, shapeInfo.y2, shapeInfo.r2
                );
                
                // Add more random color stops to the gradient for richer color blends.
                for(let j = 0; j < shapeInfo.colorStops; j++) {
                    gradient.addColorStop(j / (shapeInfo.colorStops - 1), shapeInfo.colors[j]);
                }
                ctx.fillStyle = gradient;
                ctx.strokeStyle = gradient; // Also apply to stroke for new shapes
                ctx.lineWidth = shapeInfo.lineWidth;

                // Draw the appropriate shape based on shapeType
                if (shapeInfo.shapeType < 0.4) { // Circle
                    ctx.beginPath();
                    ctx.arc(shapeInfo.x2, shapeInfo.y2, shapeInfo.r2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (shapeInfo.shapeType < 0.7) { // Rectangle
                    ctx.save();
                    ctx.translate(shapeInfo.x1, shapeInfo.y1);
                    ctx.rotate(shapeInfo.rotation);
                    ctx.fillRect(-shapeInfo.rectWidth / 2, -shapeInfo.rectHeight / 2, 
                                shapeInfo.rectWidth, shapeInfo.rectHeight);
                    ctx.restore();
                } else if (shapeInfo.shapeType < 0.9) { // Bezier Curve
                    ctx.beginPath();
                    ctx.moveTo(shapeInfo.startX, shapeInfo.startY);
                    ctx.bezierCurveTo(
                        shapeInfo.cp1x, shapeInfo.cp1y,
                        shapeInfo.cp2x, shapeInfo.cp2y,
                        shapeInfo.endX, shapeInfo.endY
                    );
                    ctx.stroke();
                } else { // Polygon
                    ctx.save();
                    ctx.translate(shapeInfo.x1, shapeInfo.y1);
                    ctx.rotate(shapeInfo.polyRotation);
                    ctx.beginPath();
                    ctx.moveTo(shapeInfo.polyRadius, 0);
                    for (let k = 1; k < shapeInfo.sides; k++) {
                        const angle = (k / shapeInfo.sides) * Math.PI * 2;
                        ctx.lineTo(
                            Math.cos(angle) * shapeInfo.polyRadius, 
                            Math.sin(angle) * shapeInfo.polyRadius
                        );
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // Store the current art configuration including all shape data
            currentArtConfig = {
                colorPalette: JSON.parse(JSON.stringify(colorPalette)),
                width,
                height,
                blurRadius,
                shapeData
            };
            
            // Reset filters and blend modes for any future drawing (like UI)
            ctx.filter = 'none';
            ctx.globalCompositeOperation = 'source-over';
        }

        /**
         * Renders the current artwork at 4K resolution and triggers download
         */
        function downloadArt4K() {
            if (!currentArtConfig) return;

            // Create a temporary canvas at 4K resolution
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Set 4K dimensions
            const width4K = 3840;
            const height4K = 2160;
            tempCanvas.width = width4K;
            tempCanvas.height = height4K;
            
            // Calculate scale factor for proper scaling
            const scaleX = width4K / currentArtConfig.width;
            const scaleY = height4K / currentArtConfig.height;
            
            // Apply the same blur filter but scaled for 4K
            const blurRadius4K = currentArtConfig.blurRadius * 
                                Math.max(scaleX, scaleY);
            tempCtx.filter = `blur(${blurRadius4K}px) saturate(170%) contrast(110%)`;
            
            // Make a copy of the color palette
            colorPalette = JSON.parse(JSON.stringify(currentArtConfig.colorPalette));
            
            // Draw each shape exactly as in the original but scaled for 4K
            for (const shape of currentArtConfig.shapeData) {
                // Apply the same blend mode
                tempCtx.globalCompositeOperation = shape.blendMode;
                
                // Scale coordinates and sizes
                const x1_4k = shape.x1 * scaleX;
                const y1_4k = shape.y1 * scaleY;
                const x2_4k = shape.x2 * scaleX;
                const y2_4k = shape.y2 * scaleY;
                const r2_4k = shape.r2 * Math.min(scaleX, scaleY);
                
                // Create the same gradient but scaled
                const gradient = tempCtx.createRadialGradient(
                    x1_4k, y1_4k, 0, 
                    x2_4k, y2_4k, r2_4k
                );
                
                // Add the same color stops
                for(let j = 0; j < shape.colorStops; j++) {
                    gradient.addColorStop(j / (shape.colorStops - 1), shape.colors[j]);
                }
                
                tempCtx.fillStyle = gradient;
                tempCtx.strokeStyle = gradient;
                tempCtx.lineWidth = shape.lineWidth * Math.min(scaleX, scaleY);
                
                // Draw the appropriate shape based on shapeType
                if (shape.shapeType < 0.4) { // Circle
                    tempCtx.beginPath();
                    tempCtx.arc(x2_4k, y2_4k, r2_4k, 0, Math.PI * 2);
                    tempCtx.fill();
                } else if (shape.shapeType < 0.7) { // Rectangle
                    const rectWidth_4k = shape.rectWidth * scaleX;
                    const rectHeight_4k = shape.rectHeight * scaleY;
                    
                    tempCtx.save();
                    tempCtx.translate(x1_4k, y1_4k);
                    tempCtx.rotate(shape.rotation);
                    tempCtx.fillRect(
                        -rectWidth_4k / 2, -rectHeight_4k / 2, 
                        rectWidth_4k, rectHeight_4k
                    );
                    tempCtx.restore();
                } else if (shape.shapeType < 0.9) { // Bezier Curve
                    tempCtx.beginPath();
                    tempCtx.moveTo(shape.startX * scaleX, shape.startY * scaleY);
                    tempCtx.bezierCurveTo(
                        shape.cp1x * scaleX, shape.cp1y * scaleY,
                        shape.cp2x * scaleX, shape.cp2y * scaleY,
                        shape.endX * scaleX, shape.endY * scaleY
                    );
                    tempCtx.stroke();
                } else { // Polygon
                    const polyRadius_4k = shape.polyRadius * Math.min(scaleX, scaleY);
                    
                    tempCtx.save();
                    tempCtx.translate(x1_4k, y1_4k);
                    tempCtx.rotate(shape.polyRotation);
                    tempCtx.beginPath();
                    tempCtx.moveTo(polyRadius_4k, 0);
                    for (let k = 1; k < shape.sides; k++) {
                        const angle = (k / shape.sides) * Math.PI * 2;
                        tempCtx.lineTo(
                            Math.cos(angle) * polyRadius_4k, 
                            Math.sin(angle) * polyRadius_4k
                        );
                    }
                    tempCtx.closePath();
                    tempCtx.fill();
                    tempCtx.restore();
                }
            }
            
            // Reset filters and blend modes
            tempCtx.filter = 'none';
            tempCtx.globalCompositeOperation = 'source-over';
            
            // Convert to data URL and trigger download
            const dataURL = tempCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'abstract-art-4k.png';
            link.href = dataURL;
            link.click();
        }

        /**
         * Toggles between normal and 4K resolution modes
         */
        function toggleResolution() {
            is4KMode = !is4KMode;
            toggleResolutionButton.textContent = is4KMode ? "Normal Resolution" : "Toggle 4K View";
            generateArt();
        }

        // --- Event Listeners ---
        regenerateButton.addEventListener('click', generateArt);
        downloadButton.addEventListener('click', downloadArt4K);
        toggleResolutionButton.addEventListener('click', toggleResolution);
        window.addEventListener('resize', generateArt);

        // Generate the initial artwork on load
        generateArt();
    </script>
</body>
</html>
